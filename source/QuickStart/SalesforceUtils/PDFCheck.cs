using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.Http;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;

using UglyToad.PdfPig;

using SfdcEnterprise;       // Enterprise WSDL generated by Salesforce. Note the small modification in the README.

namespace SalesforceUtils
{
    public class PDFCheck : SalesforceFunctionBase
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="req"></param>
        /// <param name="log"></param>
        /// <returns>'-2' : File not found in Salesforce, '-1' : Failed to check, '0' : Verified and unprotected PDF file, '1' : Password protected PDF file</returns>
        [FunctionName("PDFCheck")]
        public static async Task<IActionResult> Run(
            [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,
            ILogger log)
        {
            log.LogInformation("Create Salesforce Account - function processed a request.");

            string contentDocumentId = req.Query["ContentDocumentId"];

            bool success = true;

            String responseMessage = "-1";

            // If the login and soap clients are not initiated, then initialize
            if (loginClient == null || soapClient == null)
            {
                success = await InitializeClients();

                // Response message
                string initMessage = success
                    ? "Salesforce Web Clients created successfully."
                    : $"Salesforce Web Clients not created successfully.";

                Console.WriteLine(initMessage);

                if (!success)
                {
                    return new OkObjectResult(initMessage);
                }
            }

            queryRequest qr = new();
            qr.queryString = "SELECT VersionData FROM ContentVersion WHERE IsLatest = TRUE AND ContentDocumentId = '" + contentDocumentId + "'"; 
            qr.SessionHeader = header;

            queryResponse qresponse;

            try
            {
                qresponse = await soapClient.queryAsync(qr);

                QueryResult queryResult = qresponse.result;

                if (queryResult != null)
                {
                    sObject[] objects = queryResult.records;

                    if (objects == null)
                    {
                        log.LogInformation( "No file found for id " + contentDocumentId);
                        responseMessage = "-2";
                    }
                    else
                    {
                        byte[] content = ((SfdcEnterprise.ContentVersion)objects[0]).VersionData;

                        Stream stream = new MemoryStream(content);

                        Boolean encrypted = false;

                        try
                        {
                            UglyToad.PdfPig.PdfDocument doc = UglyToad.PdfPig.PdfDocument.Open(content);

                            if (doc.IsEncrypted)
                            {
                                encrypted = true;
                            }

                            doc.Dispose();  
                        }
                        catch (UglyToad.PdfPig.Exceptions.PdfDocumentEncryptedException)
                        {
                            encrypted = true;
                        }

                        if(encrypted)
                        {
                            responseMessage = "1";
                        }
                    }
                }
            }
            catch(System.ServiceModel.CommunicationException ce)
            {
                log.LogInformation("File size too large: " + ce.Message);
                responseMessage = "-1";
            }
            catch (Exception ex)
            {
                log.LogInformation(ex.Message);
                responseMessage = "-1";
            }

            log.LogInformation(responseMessage);

            return new OkObjectResult(responseMessage);
        }
    }
}
